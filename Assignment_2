1.You are given N activities, each having a start time and a finish time. A single person (or machine) can perform only
one activity at a time. Two activities are said to be compatible if the start time of one activity is greater than or equal

to the finish time of the other activity. Write a program using greedy strategy to select the maximum number of non-
overlapping activities that can be performed by the person.

E.g.:
Input:
N = 6
start = [1, 3, 0, 5, 8, 5]
finish = [2, 4, 6, 7, 9, 9]
Output:
Maximum number of activities = 4
Selected activities: (1, 2), (3, 4), (5, 7), (8, 9)

----------

#include <bits/stdc++.h>
using namespace std;

struct fin {
    int s_time;
    int f_time;
};

int max_activity(vector<int> start, vector<int> finish) {
    int n = start.size();
    vector<fin> activities;

    // Store start and finish times together
    for (int i = 0; i < n; i++) {
        activities.push_back({start[i], finish[i]});
    }

    // Sort activities by finish time
    sort(activities.begin(), activities.end(),
         [](fin &a, fin &b) {
             return a.f_time < b.f_time;
         });

    // Greedy activity selection
    int count = 1;
    int lastFinish = activities[0].f_time;

    for (int i = 1; i < n; i++) {
        if (activities[i].s_time >= lastFinish) {
            count++;
            lastFinish = activities[i].f_time;
        }
    }

    return count;
}

int main() {
    vector<int> start  = {1, 3, 0, 5, 8, 5};
    vector<int> finish = {2, 4, 6, 7, 9, 9};

    cout << "Maximum number of activities: "
         << max_activity(start, finish);

    return 0;
}

=========================================================================================================================================================
2. Given the arrival and departure times of all trains reaching a railway station on the same day, write a program to
determine the minimum number of platforms required so that no train has to wait for a platform. For each train, the
arrival time is always different from its departure time, but the arrival time of one train may be equal to the departure
time of another train. At any given instant, a single platform cannot be used simultaneously for the departure of one
train and the arrival of another train; therefore, in such cases, separate platforms must be allocated. [Minimum
Platforms | Practice Problems]
Input:
Train = [T1, T2, T3, T4, T5]
AT = [09:00, 09:10, 09:20, 11:00, 11:20]
DT = [09:40, 12:00, 09:50, 11:30, 11:40]
Output:
Minimum number of platforms required = 3

------------------------------------

#include <bits/stdc++.h>
using namespace std;

int minPlatforms(vector<int>& at, vector<int>& dt) {
    sort(at.begin(), at.end());
    sort(dt.begin(), dt.end());

    int i = 0, j = 0;
    int plat_needed = 0, max_platforms = 0;
    int n = at.size();

    while (i < n && j < n) {
        // Arrival happens before or at same time as departure
        if (at[i] <= dt[j]) {
            plat_needed++;
            max_platforms = max(max_platforms, plat_needed);
            i++;
        } 
        else {
            plat_needed--;
            j++;
        }
    }
    return max_platforms;
}

int main() {
    vector<int> at = {900, 910, 920, 1100, 1120};
    vector<int> dt = {940, 1200, 950, 1130, 1140};

    cout << "Minimum number of platforms required = "
         << minPlatforms(at, dt) << endl;
}

============================================================================================================================================================

4. Given two arrays deadline[ ] and profit[ ], where deadline[i] represents the last time unit by which the i-th job must be
completed, and profit[i] represents the profit earned from completing it. Each job takes exactly 1 unit of time, and only
one job can be scheduled at a time. Write a program to schedule the jobs in such a way that the total profit is maximized
while ensuring that each selected job is completed on or before its deadline. Find the number of jobs completed and
maximum profit.
E.g.:
Input:
N = 5
Jobs = [J1, J2, J3, J4, J5]
deadline = [2, 1, 2, 1, 3]
profit = [100, 19, 27, 25, 15]
Output:
Selected Jobs: [J1, J3, J5]
Maximum Profit = 142
--------------------

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Job {
    int id;
    int deadline;
    int profit;
};

int max_profit(vector<int> deadline, vector<int> profit) {
    int n = profit.size();
    vector<Job> jobs;

    int maxDeadline = 0;
    for (int i = 0; i < n; i++) {
        jobs.push_back({i + 1, deadline[i], profit[i]});
        maxDeadline = max(maxDeadline, deadline[i]);
    }

    // Sort jobs by profit (descending)
    sort(jobs.begin(), jobs.end(), [](Job &a, Job &b) {
        return a.profit > b.profit;
    });

    vector<int> slots(maxDeadline, -1); // -1 means free
    int totalProfit = 0;

    cout << "Job sequence: ";

    for (auto &job : jobs) {
        // Try to place job at the latest free slot
        for (int t = job.deadline - 1; t >= 0; t--) {
            if (slots[t] == -1) {
                slots[t] = job.id;
                totalProfit += job.profit;
                cout << "J" << job.id << " ";
                break;
            }
        }
    }

    cout << endl;
    return totalProfit;
}

int main() {
    vector<int> deadline = {2, 1, 2, 1, 3};
    vector<int> profit = {100, 19, 27, 25, 15};

    cout << "Maximum profit: " << max_profit(deadline, profit);
    return 0;
}
======================================================================================================================================================================

3. You are given N items, where each item has a value and a weight. You are also given a knapsack with a maximum
capacity W. Unlike the 0/1 Knapsack problem, you are allowed to take fractions of an item. Write a program to
maximize the total value in the knapsack without exceeding its capacity.
E.g.:
Input:
N = 3
value = [100, 60, 120]
weight = [20, 10, 40]
W = 50
Output:
Maximum value = 220

------------------

#include <bits/stdc++.h>
using namespace std;

struct Item {
    int value, weight;
};

// Comparator to sort items by value/weight ratio
bool cmp(Item a, Item b) {
    double r1 = (double)a.value / a.weight;
    double r2 = (double)b.value / b.weight;
    return r1 > r2;
}

int main() {
    int N = 3;
    int W = 50;

    vector<int> value = {100, 60, 120};
    vector<int> weight = {20, 10, 40};

    vector<Item> items;
    for (int i = 0; i < N; i++) {
        items.push_back({value[i], weight[i]});
    }

    sort(items.begin(), items.end(), cmp);

    double maxValue = 0.0;

    for (int i = 0; i < N && W > 0; i++) {
        if (items[i].weight <= W) {
            maxValue += items[i].value;
            W -= items[i].weight;
        } else {
            maxValue += items[i].value * ((double)W / items[i].weight);
            W = 0;
        }
    }

    cout << "Maximum value = " << maxValue << endl;
    return 0;
}
========================================================================================================================

5. Given a set of characters and their corresponding frequencies, write a program to construct the Huffman Tree and
generate Huffman codes for each character such that the total number of bits required for encoding is minimized.

E.g.:
Input:
Characters = [a, b, c, d, e, f]
Frequencies = [5, 9, 12, 13, 16, 45]
Output:
Character Huffman Code
a 1100
b 1101
c 100
d 101
e 111
f 0

---------------------
#include <bits/stdc++.h>
using namespace std;

struct Node {
    char ch;
    int freq;
    Node *left, *right;

    Node(char c, int f) {
        ch = c;
        freq = f;
        left = right = NULL;
    }
};

// Min heap compare
struct cmp {
    bool operator()(Node* a, Node* b) {
        return a->freq > b->freq;
    }
};

// Print codes
void print(Node* root, string s) {
    if (!root) return;

    if (root->ch != '#')
        cout << root->ch << " " << s << endl;

    print(root->left, s + "0");
    print(root->right, s + "1");
}

int main() {
    char ch[] = {'a','b','c','d','e','f'};
    int freq[] = {5,9,12,13,16,45};
    int n = 6;

    priority_queue<Node*, vector<Node*>, cmp> pq;

    // Step 1: push all characters
    for (int i = 0; i < n; i++)
        pq.push(new Node(ch[i], freq[i]));

    // Step 2: build tree
    while (pq.size() > 1) {
        Node* l = pq.top(); pq.pop();
        Node* r = pq.top(); pq.pop();

        Node* node = new Node('#', l->freq + r->freq);
        node->left = l;
        node->right = r;

        pq.push(node);
    }

    // Step 3: print codes
    cout << "Character Huffman Code\n";
    print(pq.top(), "");

    return 0;
}

=====================================================================================================================================
                                                     ADDITIONAL QUESTIONS
=====================================================================================================================================

